# 分层架构

- 示例
- 注解

有些技术是先有了设计, 然后有了实现, 比如数据库. 但对于架构/设计模式而言, 总是先遇到了问题, 解决之后, 然后总结出了架构/设计模式.

分层架构亦是如此. 架构/模式 都是为了对抗软件复杂度而提出的, 并且解决开发过程中常遇到的问题.

基于使用为先的理念, 我们先了解分层架构的例子, 实现, 然后思考为什么这么设计, 最后再去总结/了解什么是分层架构, 分层架构解决了那些问题.

## 示例
分层结构一般用于 web 开发, 常用分层如下
````
- entry/main.go
- interface & model.go
- config.example.yaml
- internal
  - cmd
    - root.go
  - controllers
  - services
  - dao
  - util/helper
````

其中, 分层结构主要是指 controllers/services/dao 三层(前后端分离项目中), 其它层多是辅助作用. 接下来我们自上而下先讲讲这三层.

### controllers
controllers 负责 输入数据 的收集, 常规校验(即不设计业务逻辑), 以及输出数据的修剪/格式化, 通过调用 services 执行相关业务逻辑.

### services
services 负责执行业务逻辑, 通过调用 dao 修改数据库. 

可能有人会疑问, 为什么由 services 负责业务逻辑, 而非 controllers 负责业务逻辑. 其实这个问题是本末倒置的,
并不是单独分出services层用来控制业务逻辑, 而是因为业务逻辑需要单独分层. 那么为什么呢?

主要原因是为了复用业务逻辑. 我们通常提供多种入口的服务(如http/grpc两种), 其传入参数/传出格式大不相同, 但是执行相同的业务逻辑, 所以 业务逻辑 应当单独抽象出一层.

据说对于更复杂的业务, services 可会被拆分为 business/services 两层架构. 

### dao
dao对外提供数据库操作的接口. dao 不应当涉及任何业务逻辑; 事务应当有业务逻辑控制, dao 不应当控制事务.

那可能你会问了, 不需要负责业务逻辑, mysql 操作也就那一套, 那 dao 是不是太单薄, 太简单了? 其实不会. dao层对程序的扩展性还是提升很大的.
1. 数据校验: 输入传入dao, dao还需要对数据做校验, 对输出数据做格式化.
2. 特殊逻辑: 一般而言, 参考 gorm, 数据库删除都是假删除(即更新`deleted_at`字段). 此时就需要在dao层判断 结构体/数据表 有无此字段, 并且依据此确定执行假删除还是真删除.
3. 设置缓存: 一般而言, 都会设置缓存以减少数据库的压力, 而部分缓存的读写也是放到dao层.
4. 再或者, 假设项目重构, 需要切换数据库(如`mysql=>mongo`), 则只需重写dao层即可.

由于 go 不像 java, 有成熟的工具可以自动生成很多代码, 所以有时直接将gorm当成dao使用了, 并没有严格按照分层架构.

### 其他
对于其他层, 解释如下
- `entry/main.go`: 入口文件, 调用 `internal/cmd/` 下相关命令启动真正的程序
- `interface & model`: 定义服务接口和数据表实体, 可看做对外的约定, 同时约束service层的实现. (todo)
- `config.example.yaml`: 项目静态配置文件. 动态配置可以使用 etcd 等工具.
- `internal`: Go 内部包声明, 被外界引用时会报错. 编译器标准, 用来维护一些私有库和局部状态.
- `cmd`: 构建cli风格程序. 当不使用依赖注入框架时, 通常在cmd下添加 bootstrap 文件用于实例化各对象.
  - `cmd/root.go`: 用于构建 linux cli 风格的程序, 可添加不同的参数执行不同的业务.
- `util/helper`: 工具包. util通常被理解为只有静态方法并且是无状态的, 既你不会创建这样一个类的实例.
  helper 可以是实用程序类, 也可以是有状态的或需要创建实例的类.

docker 部署方案参考 [docker部署](/docs/deploy/docker.md)

除了上述部分外, 通常还添加其他组件
````
- doc
- script
    - shell
    - sql
````

## 遇到的问题
分层架构并不是银弹, 在使用分层架构时, 我们通常会遇到一些问题.

在电子商务系统中, 商品SKU的设计一直很有挑战性. 以此为例, 我们可以看下会遇到那些问题.

商品SKU系统如下, 由于 商品SKU 系统本身很复杂, 这里只拿出一部分来讲.
1. product 表: 商品表, 商品依赖于规格和文件: 每个商品都有多个规格和多个文件(用于描述文件).
2. sku 表: 规格表, 存储商品规格, 包括 price/stock/extend. extend 保存的时规格属性的 json 字符串.
3. file 表: 文件记录表, 文件存储于OSS, file 表记录文件相关信息与 OSS-URL 地址.

通常, 我们先保存文件然后创建商品, 所以我们在商品表中添加 fids 用于记录属于该商品的文件集合.

通常, 我们先创建商品然后添加规格, 所以我们在 sku 表中存储 productID.

表结构假设如下
```Go
type Product struct{
  Name string
  Desc string
  Fids string
  ...
}
type SKU struct{
  ProductID int64
  Price     int
  Stock     int
  extend  string
  ...
}
type File struct{
  Name  string
  URL   string
  Size  int
  ...
}
```

假设存在以下需求:
1. 删除商品时, 同时需要: 删除SKU记录, 删除file记录, 将oss上文件移到存档区.
2. 支持单独更新 sku, 单独更新 file, 单独更新 Product SPU 信息. (SPU: 商品基础信息单元)

因为需求2, 我们有单独更新 sku/file/product 的需求, 按照 业务领域/职责范围, 我们将 sku/file/product 拆分到三个service.

### 服务相互依赖
如此我们产生了一个问题: 如何删除商品时, 同时删除 SKU/File, 同时更改oss上的文件?
简单来讲, 就是如何解决业务逻辑(service)之间的互相依赖? 通常, 我们有如下解决思路
1. 方法一: 借助 controller 实现. 在上文中我们说过, 这会导致业务逻辑无法复用, 排除.
2. 方法二: 借助 dao 层. dao 层貌似可以解决很多问题, 如 `删除文件时需要同时删除表记录和存档文件`,
  我们将 删除文件/缓存 等操作封装在 dao 层, 对service屏蔽具体实现, 从而实现了需求. 
  但是, 当存在需求是 `删除商家时, 删除该商家下的所有商品`, 难道我们要将上述这些逻辑都写到商品的dao层么?
  显然不应该. 因此, 借助dao层不能满足所有需求, 也没有解决基本问题: 业务逻辑间的互相依赖.
3. 方法三: 借助 business 层. 即将与其他服务有交互的部分放到business层, service只有本业务领域的逻辑.
  理论上可以解决顺序上互相依赖的场景, 如先执行A后执行B最后执行C; 但对于交叉依赖的场景并没有明显效果,
  如修改A时需要根据条件查询B, 如此还是无法解决掉service之间的互相依赖.

尽量减少service之间互相依赖是为了解耦, 从而使程序更健壮, 更易扩展. 但是, 经过分析, 
我们确定业务逻辑之间的互相依赖在某些情况下是不可避免的, 或者说service之间的互相依赖时不可避免的.

但是, 我们可以使用一些常见的方案来优化服务之间的互相依赖, 使其损害不至于过大. 方法如下
1. 依赖注入: 通过在 `internal/cmd/` 下添加 bootstrap 文件, 在bootstrap中, 我们初始化所有服务, 然后将服务注入到各service中. 
2. 面向接口开发: 我们在项目最外层定义了数据库结构体和服务接口, 而所有的 controller/service 都遵循此约束进行开发和使用.

### 事务传递
关于 复用/依赖注入/面向接口编程 的好处有很多, 此处我不再讲述. 我想说多说一句, 没有什么架构是可以解决所有问题的,
也没有架构生来就是设计好的, 一个好的架构应当是适合我们业务系统的, 且随着业务变化不断演化的.

比如说我再提一个问题, 加入删除商品时发生了异常, 如何回滚 SKU/File 表记录的删除? 你肯定想到了使用事务, 但是如何使用呢?
当采用service互相依赖的方式后, 你又如何从 服务A 将 数据库对象(`tx=db.Begin()`) 传递给 服务B 呢?

当我们需要在不同服务之间传递事务时, 有哪些方案呢?

使用分布式事务(XA事务). 当不采用分布式部署时, XA事务代价太大, 并不是较好的解决方案.

直接在函数声明中添加 tx 参数, 调用时传入参数, 被调用服务内部判断 `tx == nil` 则开启自身的事务, 否则使用传递的事务.

这种方法未曾不可, 只不过不够优雅. 首先, 事务对象 是上下文的一部分, 却不应该是接口的一部分, 如果现在有了事务, 我们就加一个参数, 
后续有了其他上下文条件呢? 依次加参数么? 显然时不合理的. 

考虑到事务可以属于上下文的一部分, 且服务是否采用事务与事务的实现无关, 同时参考 Spring 的 `@Transactional` 注解, 
借助 AOP 思想和 context 上下文理念, 我们可以这样实现Go服务间的事务传递

添加 aop package, 添加 `SetTransaction()` 方法, 对于需要事务传播的函数, 在函数内部调用 `aop.SetTransaction()`
函数即可启用事务传播属性.

对于每个服务添加 `ctx context.Context` 参数, 用于传递上下文信息, 此处主要时用来传递 开启事务的db对象.
(需要注意的是, 不要滥用context) 

其中的关键在于, `SetTransaction()` 方法的实现.

方法签名如下 `SetTransaction(context.Context, database.DB)(newCtxcontext.Context, teardown func(database.DB,error), tx database.DB, err error)`, 其中
- newCtx: 新返回的 上下文信息, 后续都使用此 context. (其实可以将传入的 context 改为指针, 如此直接修改传入参数即可, 无需返回值了)
- teardown: 作用类似 析构函数, 当函数执行结束时, 根据传入的error值判断事务是 commit 还是 rollback.
- tx: 已开启事务的db对象. 程序只用此对象操作数据库
- err: 函数执行时发生的异常.

源码参考 [aop.SetTransaction](https://github.com/xgxw/foundation-go/blob/master/aop/transtion.go)

## 注解
### dao
dao (database access object, 数据访问对象), 为某种类型的数据库或其他持久性机制提供一个抽象接口的对象(维基百科).

dao 的优点在于: 减少代码量, 提升复用; 以及通过屏蔽具体实现, 从而可以进行内部优化. 具体如下.
- 通过映射应用程序对持久层的调用, DAO提供一些特定的数据操作, 而无需暴露数据库细节.
- 因为 dao 只需要保证接口输入输出保持稳定即可, 所以dao可以进行内部优化如 设置连接池, 添加缓存等操作优化性能.

dao 的缺点在于: 一次查询可能会被拆分为多次查询. 如查询订单信息时, 需要依次查询 orders/products/sku, 而不使用dao时,
拼装sql依次查询即可得出.